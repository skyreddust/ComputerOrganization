驻留集：指请求分页存储管理中给进程分配的物理块（即页框）的集合
【注】若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低
工作集：指在某段时间间隔里，进程实际访问页面的集合
窗口尺寸：页面访问序列的集合，窗口尺寸有多大，访问序列中就有多少个页面
抖动：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。
产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够，即驻留集太小）

页面置换算法：
1.最佳置换算法（OPT）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率
2.先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面
  把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块
  Belady 异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
  只有 FIFO 算法会产生 Belady 异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问
3.最近最久未使用置换算法（LRU）：每次淘汰的页面是最近最久未使用的页面
  赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面

缺页总次数 = 缺页中断总次数 = 一开始页面载入时预分配大小 + 产生页置换的总次数
缺页率 = 缺页总次数/页号序列总数

4.时钟置换算法（CLOCK）
·为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列
·当某页被访问时，其访问位置为 1，否则保持为 0
·当需要淘汰一个页面时，只需检查页的访问位。如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，继续检查下一个页面
·若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描
【注】第二轮扫描中一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描

5.改进型时钟置换算法（CLOCK）：用 （访问位，修改位） 的形式表示各页面状态
·将所有可能被置换的页面排成一个循环队列
·第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位
·第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0
·第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位
·第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换
【注】由于第二轮已将所有帧的访问位设为 0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描
【注】该算法仅修改访问位，不修改修改位
【注】该算法的本质是将页面划分为了四个优先级，优先级越大，被置换的可能性就越小。
（0,0）：第一优先级，最近没访问，且没修改的页面。
（0,1）：第二优先级，最近没访问，但修改过的页面。
（1,0）：第三优先级：最近访问过，但没修改的页面。
（1,1）：第四优先级：最近访问过，且修改过的页面。
算法规则：
第一轮：淘汰（0, 0），若没找到就进行第二轮。
第二轮：淘汰（0, 1），若没找到就进行第三轮。
第三轮：淘汰（1, 0），若没找到就进行第四轮。
第四轮：淘汰（1, 1）。

编译：由编译程序将目标源代码编译成若干目标模块
链接：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成完整的装入模块。此阶段将形成程序的逻辑地址
  静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开
  装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式
  运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享
装入：装入程序将装入模块装入内存。此阶段将程序的逻辑地址变换为程序的物理地址
  绝对装入：如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改
  可重定位装入（静态重定位）：程序中的地址都是相对于起始地址的，对程序的指令和地址修改通常是在装入时一次完成的。系统必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间
  动态重定位：装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行，需要重定位寄存器的支持
【注】整个系统只有一个重定位寄存器
【注】程序中所使用的绝对地址（物理地址、实地址），可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中釆用的是符号地址（逻辑地址、虚拟地址），编译或汇编时再转换为绝对地址。（程序中使用符号名来访问存储单元，而符号名存储的是逻辑地址，而逻辑地址能够转化为物理地址）
